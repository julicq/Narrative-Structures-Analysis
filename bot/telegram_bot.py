# bot/telegram_bot.py

import asyncio
import os
from dotenv import load_dotenv
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram import ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import (
    Application,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackQueryHandler,
)
from narr_mod import StructureType
from service.evaluator import NarrativeEvaluator
from service import initialize_llm
from app.routes import extract_doc_text, extract_text_from_pdf
from shared.config import Config

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class TelegramBot:
    def __init__(self):
        self.evaluator = None
        self.application = None
    
    async def setup(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞"""
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LLM –∏ evaluator
        llm = initialize_llm()
        if not llm:
            raise ValueError("Failed to initialize LLM")
        
        self.evaluator = NarrativeEvaluator(llm)
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        self.application = Application.builder().token(Config.TELEGRAM_TOKEN).build()
        
        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        self.register_handlers()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        await self.application.initialize()
        await self.application.start()
        
        return self.application

    def register_handlers(self):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥"""
        if not self.application:
            raise RuntimeError("Application not initialized")

        # –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(MessageHandler(
            filters.TEXT & ~filters.COMMAND, 
            self.handle_message
        ))
        self.application.add_handler(CallbackQueryHandler(self.button))
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (—Ñ–∞–π–ª–æ–≤)
        self.application.add_handler(MessageHandler(
            filters.Document.ALL, 
            self.analyze_file
        ))
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
        self.application.add_error_handler(self.error_handler)

    def get_main_keyboard(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã"""
        keyboard = [
            [KeyboardButton("–í—ã–±—Ä–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É"), KeyboardButton("–ü–æ–º–æ—â—å")],
            [KeyboardButton("–ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã")]
        ]
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        user = update.effective_user
        keyboard = self.get_main_keyboard()
        await update.message.reply_text(
            f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! üëã\n"
            "–Ø –±–æ—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞—Ä—Ä–∞—Ç–∏–≤–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä.\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:",
            reply_markup=keyboard
        )

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
        help_text = (
            "ü§ñ *–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞:*\n\n"
            "1. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞\n"
            "2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã:\n"
            "   /start - –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n"
            "   /help - –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n\n"
            "üìÑ *–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã —Ñ–∞–π–ª–æ–≤:*\n"
            "‚Ä¢ TXT - —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã\n"
            "‚Ä¢ DOC/DOCX - –¥–æ–∫—É–º–µ–Ω—Ç—ã Word\n"
            "‚Ä¢ PDF - PDF –¥–æ–∫—É–º–µ–Ω—Ç—ã\n\n"
            "–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ:\n"
            "‚Ä¢ –í—ã–±—Ä–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞\n"
            "‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"
        )
        await update.message.reply_text(help_text, parse_mode='Markdown')

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        text = update.message.text
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ –º–µ–Ω—é
        if text in ["–í—ã–±—Ä–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É", "–ü–æ–º–æ—â—å", "–ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"]:
            await self.handle_button(update, context)
            return

        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
            processing_message = await update.message.reply_text(
                "üîÑ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ç–µ–∫—Å—Ç... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è."
            )
            
            structure = context.user_data.get('selected_structure', "Auto-detect")
            await self.process_text(update, context, text, structure)
            await processing_message.delete()
                
        except Exception as e:
            error_message = f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}"
            await update.message.reply_text(error_message)
            logger.error(f"Error in handle_message: {e}")

    async def handle_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –∫–Ω–æ–ø–∫–∏"""
        text = update.message.text
        if text == "–í—ã–±—Ä–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É":
            await self.choose_structure(update, context)
        elif text == "–ü–æ–º–æ—â—å":
            await self.help_command(update, context)
        elif text == "–ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã":
            context.user_data['selected_structure'] = "Auto-detect"
            await update.message.reply_text(
                "–í—ã–±—Ä–∞–Ω–æ –∞–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ —Ñ–∞–π–ª –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞."
            )

    async def choose_structure(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"""
        keyboard = [
            [InlineKeyboardButton(
                StructureType.get_display_name(structure.value),
                callback_data=structure.value
            )]
            for structure in StructureType if structure != StructureType.AUTO_DETECT
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –Ω–∞—Ä—Ä–∞—Ç–∏–≤–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:',
            reply_markup=reply_markup
        )

    async def button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ inline –∫–Ω–æ–ø–æ–∫"""
        query = update.callback_query
        await query.answer()
        context.user_data['selected_structure'] = query.data
        await query.edit_message_text(text=f"–í—ã–±—Ä–∞–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞: {query.data}")

    async def analyze_file(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ñ–∞–π–ª–æ–≤"""
        try:
            file = await update.message.document.get_file()
            file_name = update.message.document.file_name
            file_extension = os.path.splitext(file_name)[1].lower()

            if file_extension not in ['.doc', '.docx', '.pdf', '.txt']:
                await update.message.reply_text(
                    "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ doc, docx, pdf –∏–ª–∏ txt —Ñ–∞–π–ª."
                )
                return

            processing_message = await update.message.reply_text(f"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–∞–π–ª {file_name}...")
            
            try:
                await file.download_to_drive(file_name)
                
                if file_extension in ['.doc', '.docx']:
                    text = extract_doc_text(file_name)
                elif file_extension == '.pdf':
                    with open(file_name, 'rb') as f:
                        text = extract_text_from_pdf(f)
                else:  # .txt
                    with open(file_name, 'r', encoding='utf-8') as f:
                        text = f.read()
                        
            finally:
                if os.path.exists(file_name):
                    os.remove(file_name)

            if not text:
                await processing_message.edit_text("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –∏–∑ —Ñ–∞–π–ª–∞.")
                return

            structure = context.user_data.get('selected_structure', "Auto-detect")
            await self.process_text(update, context, text, structure)
            await processing_message.delete()
            
        except Exception as e:
            logger.error(f"Error in analyze_file: {e}")
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )

    async def process_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text: str, structure: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞"""
        try:
            if structure == "Auto-detect":
                structure = self.evaluator.classify(text)

            result = self.evaluator.analyze_specific_structure(text, structure)

            response = f"–ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã: {result['structure']}\n\n"
            response += f"–ê–Ω–∞–ª–∏–∑:\n{result['analysis']}\n\n"
            if 'visualization' in result:
                response += f"–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è:\n{result['visualization']}"

            # –†–∞–∑–±–∏–≤–∞–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —á–∞—Å—Ç–∏
            if len(response) > 4096:
                for x in range(0, len(response), 4096):
                    await update.message.reply_text(response[x:x+4096])
            else:
                await update.message.reply_text(response)
                
        except Exception as e:
            logger.error(f"Error in process_text: {e}")
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ —Ç–µ–∫—Å—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
        logger.error(f"Exception while handling an update: {context.error}")
        if update and update.message:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )

async def run_bot():
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
    bot = TelegramBot()
    await bot.setup()
    await bot.application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True
    )

def main():
    """–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞"""
    try:
        asyncio.run(run_bot())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Fatal error: {e}")

if __name__ == '__main__':
    main()
